----------------------
-- 貨幣管理機器の部
----------------------

module 貨幣基本
exports all
definitions

types
枚数 = nat;
貨幣 = 紙幣 | 硬貨;
紙幣 = <円1000>;
硬貨 = <円10> | <円50> | <円100> | <円500>;
金額 = nat;
硬貨枚数 = map 硬貨 to 枚数;

values
紙幣種類集合 : set of 紙幣 = {<円1000>};
硬貨種類集合 : set of 硬貨 = {<円500>,<円100>,<円50>,<円10>};
紙幣金額 : map 紙幣 to 金額 = {<円1000> |-> 1000};
硬貨金額 : map 硬貨 to 金額 = {<円500> |-> 500, <円100> |-> 100, <円50> |-> 50, <円10> |-> 10};

end 貨幣基本


module 貨幣投入口
exports all
imports from 貨幣基本 all, from 貨幣管理 all, from 販売管理 all

definitions

types
紙幣保持 = 貨幣基本`枚数
inv a紙幣保持 == a紙幣保持=0 or a紙幣保持=1;

硬貨保持 = 貨幣基本`硬貨枚数
inv a硬貨保持 == a硬貨保持(<円10>)<=20 and a硬貨保持(<円50>)<=20 and a硬貨保持(<円100>)<=20 and a硬貨保持(<円500>)<=10;

state s貨幣投入口 of
  s紙幣保持 : 紙幣保持
  s硬貨保持 : 硬貨保持
  init s == s = mk_s貨幣投入口(0,{<円10>|->0,<円50>|->0,<円100>|->0,<円500>|->0})
end  

operations
-- 基本的に、紙幣も硬貨も１枚ごとに投入する
紙幣投入 : 貨幣基本`紙幣 ==> ()
紙幣投入(a紙幣) == ( s紙幣保持 := 1; 販売管理`残高増(貨幣基本`紙幣金額(<円1000>)) )
pre a紙幣=<円1000> and s紙幣保持=0 and 紙幣受付可能(); --紙幣金庫が満タンじゃないことも考慮する
/*紙幣投入 : 貨幣基本`紙幣 * 貨幣基本`枚数 ==> ()
紙幣投入(a紙幣,a枚数) == s紙幣保持 := 1
pre a紙幣=<円1000> and a枚数=1 and s紙幣保持=0;
紙幣投入 : () ==> ()
紙幣投入() == s紙幣保持 := 1
pre s紙幣保持=0;*/

硬貨投入 : 貨幣基本`硬貨 ==> ()
硬貨投入(a硬貨) == ( s硬貨保持(a硬貨) := s硬貨保持(a硬貨) + 1; 販売管理`残高増(貨幣基本`硬貨金額(a硬貨)) )
pre if a硬貨=<円500> then s硬貨保持(a硬貨)<10 else s硬貨保持(a硬貨)<20;
/*硬貨投入 : 貨幣基本`硬貨 * 貨幣基本`枚数 ==> ()
硬貨投入(a硬貨,a枚数) == s硬貨保持(a硬貨) := s硬貨保持(a硬貨) + a枚数
pre if a硬貨=<円500> then a枚数+s硬貨保持(a硬貨)<=10 else a枚数+s硬貨保持(a硬貨)<=20;*/

--返金処理() r: 返金
--返金処理() == retuen a返金  --陽仕様では返金処理の内容を定義しないつもりですが、出力の条件を書くために、returnだけにしました。
--post if (s残高~ >= 1000 and s紙幣保持~>0) then r.紙幣(<円1000>)=1 else r.紙幣(<円1000>)=0;

紙幣受付可能 : () ==> bool
紙幣受付可能() == return not 貨幣管理`紙幣金庫満タン？();

紙幣保持数 : () ==> 貨幣基本`枚数
紙幣保持数() == return s紙幣保持;

硬貨保持数 : () ==> map 貨幣基本`硬貨 to 貨幣基本`枚数
硬貨保持数() == return s硬貨保持;

-- 投入した紙幣と硬貨の合計金額を計算する（不要と判断）
--投入金額 : () ==> 貨幣基本`金額
--投入金額() == return ( 1000 * s紙幣保持 + 500 * s硬貨保持(<円500>) + 100 * s硬貨保持(<円100>) + 50 * s硬貨保持(<円50>) + 10 * s硬貨保持(<円10>) );

-- 販売完了して、紙幣と硬貨を格納し、投入口を空に戻す
-- 販売完了 : () ==> ()
-- 販売完了
-- 問題点：投入した紙幣と硬貨の処理？返金に使う？それとも金庫とチューブに格納する？

紙幣を返す : () ==> ()
紙幣を返す() == s紙幣保持 := 0
pre s紙幣保持 > 0;

紙幣を格納する : () ==> ()
紙幣を格納する() == (貨幣管理`紙幣を格納する(); s紙幣保持 := 0)
pre s紙幣保持 > 0;

硬貨を返す : 貨幣基本`硬貨 ==> ()
硬貨を返す(a) == s硬貨保持(a) := s硬貨保持(a) - 1
pre s硬貨保持(a) > 0;

硬貨を格納する : 貨幣基本`硬貨 ==> () --全部格納してしまう
硬貨を格納する(a) == (貨幣管理`硬貨を格納する(a,s硬貨保持(a)); s硬貨保持(a) := 0)
pre s紙幣保持 > 0;

貨幣を格納する : () ==> ()
貨幣を格納する() == (
  if s紙幣保持 = 1 then ( 貨幣管理`紙幣を格納する(); s紙幣保持 := 0 ) else skip;
  if s硬貨保持(<円500>) > 0 then ( 貨幣管理`硬貨を格納する(<円500>,s硬貨保持(<円500>)); s硬貨保持(<円500>) := 0 ) else skip;
  if s硬貨保持(<円100>) > 0 then ( 貨幣管理`硬貨を格納する(<円100>,s硬貨保持(<円100>)); s硬貨保持(<円100>) := 0 ) else skip;
  if s硬貨保持(<円50>) > 0 then ( 貨幣管理`硬貨を格納する(<円50>,s硬貨保持(<円50>)); s硬貨保持(<円50>) := 0 ) else skip;
  if s硬貨保持(<円10>) > 0 then ( 貨幣管理`硬貨を格納する(<円10>,s硬貨保持(<円10>)); s硬貨保持(<円10>) := 0 ) else skip;
);

-- バックドア for 状態アクセス
get_state : () ==> s貨幣投入口
get_state() == return s貨幣投入口;

set_state : s貨幣投入口 ==> ()
set_state(a) == (s紙幣保持 := a.s紙幣保持; s硬貨保持 := a.s硬貨保持);

end 貨幣投入口


module 貨幣管理
exports all
imports from 貨幣基本 all
definitions

values
紙幣最大枚数 : 貨幣基本`枚数 = 1000;
硬貨最大枚数 : 貨幣基本`枚数 = 100;

state s貨幣管理 of
  紙幣金庫 : 貨幣基本`枚数
  硬貨金庫 : 貨幣基本`硬貨枚数
  硬貨チューブ : 貨幣基本`硬貨枚数
  init s == s = mk_s貨幣管理( 0, {c2 |-> 0 | c2 in set 貨幣基本`硬貨種類集合}, {c3 |-> 0 | c3 in set 貨幣基本`硬貨種類集合} )
  inv mk_s貨幣管理(a紙幣金庫,-,a硬貨チューブ) ==  a紙幣金庫  <= 紙幣最大枚数 and 
                                            forall a硬貨枚数 in set rng a硬貨チューブ & a硬貨枚数 <= 硬貨最大枚数
end
--  init s == s = mk_s貨幣管理( {c2 |-> 0 | c2 in set 貨幣基本`紙幣種類集合}, {c2 |-> 0 | c2 in set 貨幣基本`硬貨種類集合}, {c3 |-> 0 | c3 in set 貨幣基本`硬貨種類集合} )
--  init s == s = mk_s貨幣管理( {<円1000> |-> 0}, {c2 |-> 0 | c2 in set {<円10>,<円50>,<円100>,<円500>}}, {c3 |-> 0 | c3 in set {<円10>,<円50>,<円100>,<円500>}} )
--  init s == s = mk_s貨幣管理( {<円1000> |-> 0}, {<円10> |-> 0, <円50> |-> 0, <円100> |-> 0, <円500> |-> 0}, {<円10> |-> 0, <円50> |-> 0, <円100> |-> 0, <円500> |-> 0} )

values
硬貨チューブhalf : 貨幣基本`硬貨枚数 = {<円10>|->50,<円50>|->50,<円100>|->50,<円500>|->50};
紙幣金庫half : 貨幣基本`枚数 = 500;

operations
-- 紙幣格納は、紙幣投入口に入れた紙幣と格納する（一回は１枚）
-- 硬貨格納は、硬貨チューブが満杯になる時だけする。しかも溢れる分だけ格納する
/*  紙幣を格納する : 貨幣基本`紙幣 * 貨幣基本`枚数 ==> ()
    紙幣を格納する(a紙幣,a枚数) == (紙幣金庫(a紙幣) := 紙幣金庫(a紙幣) + a枚数)
    pre a枚数=1 and 紙幣金庫(a紙幣) < 紙幣最大枚数;*/
  紙幣を格納する : () ==> ()
    紙幣を格納する() == (紙幣金庫 := 紙幣金庫 + 1)
    pre 紙幣金庫 < 紙幣最大枚数;

/*  硬貨を格納する : 貨幣基本`硬貨 * 貨幣基本`枚数 ==> ()
    硬貨を格納する(a硬貨, a枚数) == let a合計枚数 = 硬貨チューブ(a硬貨)+a枚数
     in (if a合計枚数 >= 硬貨最大枚数 then
        (let a残枚数 = a合計枚数-硬貨最大枚数 in (硬貨金庫に格納する(a硬貨,硬貨最大枚数);硬貨チューブ(a硬貨):=a残枚数)) else 
        (硬貨チューブ(a硬貨):=硬貨チューブ(a硬貨)+a枚数));*/

  硬貨を格納する : 貨幣基本`硬貨 * 貨幣基本`枚数 ==> ()
    硬貨を格納する(a硬貨, a枚数) == 
     if 硬貨チューブ(a硬貨) = 硬貨最大枚数 then
       硬貨金庫に格納する(a硬貨,a枚数)
     else
       let a合計枚数 = 硬貨チューブ(a硬貨)+a枚数
       in (if a合計枚数 >= 硬貨最大枚数 then
            (let a超えた枚数 = a合計枚数-硬貨最大枚数 in (硬貨金庫に格納する(a硬貨,a超えた枚数);硬貨チューブ(a硬貨):=硬貨最大枚数))
           else 
            (硬貨チューブ(a硬貨):=硬貨チューブ(a硬貨)+a枚数));

  硬貨金庫に格納する : 貨幣基本`硬貨 * 貨幣基本`枚数 ==> ()
    硬貨金庫に格納する(a硬貨, a枚数) == (硬貨金庫(a硬貨) := 硬貨金庫(a硬貨) + a枚数);

  貨幣収集 : () ==> ()
    貨幣収集() == (紙幣金庫 := 0; 硬貨金庫 := {<円10> |-> 0, <円50> |-> 0, <円100> |-> 0, <円500> |-> 0} );

  -- 状況・状態の判断
  紙幣金庫満タン？ : () ==> bool
    紙幣金庫満タン？() == return 紙幣金庫 = 紙幣最大枚数; -- 1000円札だけ考慮する。

  釣銭切れ？ : () ==> bool
    釣銭切れ？() == return (硬貨チューブ(<円100>) <= 8 or 硬貨チューブ(<円10>) <= 8);

  硬貨チューブ内容 : () ==> map 貨幣基本`硬貨 to 貨幣基本`枚数
    硬貨チューブ内容() == return 硬貨チューブ;

硬貨を返す : 貨幣基本`硬貨 ==> ()
硬貨を返す(a) == 硬貨チューブ(a) := 硬貨チューブ(a) - 1
pre 硬貨チューブ(a) > 0;

  -- バックドア for 状態アクセス
  get_state : () ==> s貨幣管理
    get_state() == return s貨幣管理;

  set_state : s貨幣管理 ==> ()
    set_state(a) == (紙幣金庫 := a.紙幣金庫; 硬貨金庫 := a.硬貨金庫; 硬貨チューブ := a.硬貨チューブ);

  硬貨チューブ設定 : 貨幣基本`硬貨枚数 ==> ()
    硬貨チューブ設定(a) == 硬貨チューブ := a;
  紙幣金庫設定 : 貨幣基本`枚数 ==> ()
    紙幣金庫設定(a) == 紙幣金庫 := a;

end 貨幣管理




----------------------
-- 商品管理機器の部
----------------------

module 商品管理
exports all
definitions

values
ラック格納上限 : nat = 30;
ラック数 : nat = 30;
容量別集合 : set of 容量別 = {<缶250ml>, <缶350ml>, <缶500ml>, <ペットボトル500ml>};

types
容量別 = <缶250ml> | <缶350ml> | <缶500ml> | <ペットボトル500ml>;
価格型 = 貨幣基本`金額
  inv s == s mod 10 = 0;
温度モード = <冷> | <温>;
ラック番号 = nat1
  inv rn == rn <= ラック数;
商品数 = nat;

商品種別 ::
  品名 : seq of char
  容量 : 容量別
  価格 : 価格型
  温度 : 温度モード;

--ラック ::
--  商品 : map ラック番号 to [商品種別]
--  保有数 : 商品数
--  温度 : 温度モード
--  inv r == r.保有数 <= ラック格納上限
--;

-- 商品管理はラック商品とラック保有数をキープする
-- 商品種別ごとの在庫数は操作で調査することにする（状態として保持しない）
state s商品管理 of
  sラック商品 : seq of [商品種別]
  sラック商品数 : seq of 商品数
  inv s == len s.sラック商品 = ラック数 and
           len s.sラック商品数 = ラック数 and
           forall i in set {1,...,ラック数} & s.sラック商品数(i) <= ラック格納上限
  init s == s = mk_s商品管理( [ nil | n in set {1,...,ラック数} ], [ 0 | n in set {1,...,ラック数}] )
end
--  商品種別集合 : set of 商品種別
--  ラック商品 : map ラック番号 to [商品種別]
--  ラック保有数 : map ラック番号 to 商品数
--  在庫数 : map 商品種別 to 商品数
           --forall a,b in set s.商品種別集合 & 同じ商品種別？(a,b)=false and
           --dom s.在庫数 = s.商品種別集合 and
/*  inv s == card dom s.ラック商品 = ラック数 and
           card dom s.ラック保有数 = ラック数 and
           --forall a,b in set s.商品種別集合 & 同じ商品種別？(a,b)=false and
           --dom s.在庫数 = s.商品種別集合 and
           forall n in set rng s.ラック保有数 & n <= ラック格納上限 */
--  init s == s = mk_s商品管理({},{i|->nil | i in set {1, ..., ラック数}},{i|->0 | i in set {1, ..., ラック数}},{|->})
--  init s == s = mk_s商品管理({i|->nil | i in set {1, ..., ラック数}},{i|->0 | i in set {1, ..., ラック数}})

values
商品1 : 商品種別 = mk_商品種別("foo drink", <缶250ml>,100,<冷>);
商品2 : 商品種別 = mk_商品種別("foo drink", <缶350ml>,120,<冷>);
商品3 : 商品種別 = mk_商品種別("foo drink", <缶500ml>,150,<冷>);
商品4 : 商品種別 = mk_商品種別("foo drink", <ペットボトル500ml>,180,<冷>);
ラック商品1 : seq of [商品種別] = [商品1,商品1,商品1, 商品2,商品2,商品2, 商品3,商品3,商品3, 商品4,商品4,商品4, nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil];
ラック商品数1 : seq of 商品数 = [10,10,10,10,10,10,10,10,10,10,10,10, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

functions
-- この比較関数は不要らしい
--同じ商品種別？ : 商品種別 * 商品種別 -> bool
--同じ商品種別？(a,b) == a.品名=b.品名 and a.容量=b.容量 and a.価格=b.価格 and a.温度=b.温度;

operations
--商品種別集合 : () ==> set of 商品種別
--商品種別集合() == return rng ラック商品;

在庫数 : () ==> map 商品種別 to 商品数
在庫数() == return { a |-> 商品別在庫数(a) | a in set elems sラック商品 & a <> nil };

商品別在庫数 : 商品種別 ==> 商品数
商品別在庫数(a) ==
let s = [ ラック商品数(i) | i in set {1,...,ラック数} & sラック商品(i) = a ]
in return sumofseq(s);

sumofseq : seq of nat ==> nat
sumofseq(s) == 
if len s > 1 then return sumofseq(tl s)
else return s(1);

-- ラック内の商品の総金額を算出する操作
商品総金額 : () ==> 価格型
商品総金額() == is not yet specified;

-- 販売が行われるときのラックの操作
ラック商品送出 : ラック番号 ==> ()
ラック商品送出(a) == sラック商品数(a) := ラック商品数(a) - 1
pre a <= ラック数 and ラック商品数(a) > 0;

--ラック温度制御 : ラック番号 * 温度モード ==> ()
--ラック温度制御(a番号,aモード) == ラック列(a番号).ラック商品温度モード := aモード
--pre a番号 <= len ラック列;

ラック商品数 : ラック番号 ==> 商品数
ラック商品数(a) == return sラック商品数(a);

ラック商品種別 : ラック番号 ==> [商品種別]
ラック商品種別(a) == return sラック商品(a);
--pre sラック商品(a) <> nil;

ラック商品価格 : ラック番号 ==> 価格型
ラック商品価格(a) == return sラック商品(a).価格
pre sラック商品(a) <> nil;

-- ラック商品を設定する操作(バックドアを利用する)
-- バックドア for 状態アクセス
get_state : () ==> s商品管理
get_state() == return s商品管理;

set_state : s商品管理 ==> ()
set_state(a) == (sラック商品 := a.sラック商品; sラック商品数 := a.sラック商品数);

ラック商品設定 : seq of [商品種別] * seq of 商品数 ==> ()
ラック商品設定(a,b) == (sラック商品 := a; sラック商品数 := b);

end 商品管理


-- 販売管理機器の部
-- マスタCPU相当でボタンとラック対応も含める

module 販売管理
exports all
imports from 貨幣基本 all, from 貨幣管理 all, from 商品管理 all, from 貨幣投入口 all, from IO all
definitions

types
ボタン番号 = nat
inv s == s <= 商品管理`ラック数 and s > 0;

--  紙幣 : map 貨幣基本`紙幣 to 貨幣基本`枚数

返金::
  紙幣 : 貨幣基本`枚数
  硬貨 : 貨幣基本`硬貨枚数;

ボタンとラック対応関係 = seq of set of 商品管理`ラック番号
inv s == len s = 商品管理`ラック数;

state s販売管理 of
  販売ボタン : ボタンとラック対応関係
  残高 : 貨幣基本`金額
  init s == s = mk_s販売管理([{} | i in set {1,...,商品管理`ラック数} ],0)
  -- 不変条件：ボタンが対応するラックの商品が一致すること
  inv s == forall i in set {1,...,商品管理`ラック数} &
           if card s.販売ボタン(i) > 1 then
             forall a,b in set s.販売ボタン(i) & ラック商品種別(a) = ラック商品種別(b)
           else true
  -- 空列は不変条件違反なので空集合の列にした
end

values
硬貨数0000 : 貨幣基本`硬貨枚数 = {<円500> |-> 0, <円100> |-> 0, <円50> |-> 0, <円10> |-> 0};
硬貨数1111 : 貨幣基本`硬貨枚数 = {<円500> |-> 1, <円100> |-> 1, <円50> |-> 1, <円10> |-> 1};
ボタン設定1 : ボタンとラック対応関係 = [{1,2,3},{1,2,3},{1,2,3}, {4,5,6},{4,5,6},{4,5,6}, {7,8,9},{7,8,9},{7,8,9}, {10,11,12},{10,11,12},{10,11,12}, {},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{}];

operations
-- ラック商品にアクセスための操作
ラック商品種別 : 商品管理`ラック番号 ==> 商品管理`商品種別
ラック商品種別(a) == return 商品管理`ラック商品種別(a);

-- 購入するには、商品ごとに釣銭の確認をすることが必要（事前条件）
-- 表示ランプ、投入口・出し口の動作とセンサーは記述しない

-- 販売可能: ボタンに対応するラックの中に、条件に合うラックが存在んする
-- -->   ラックに商品種別が設定されている and ラックに商品がある and 残高が足りる and 釣銭が出せられる
-- 販売可能はボタンごとで判断する、販売可能は販売制御で判断する
販売可能ボタン？ : ボタン番号 ==> bool
販売可能ボタン？(a) == return exists t in set 販売ボタン(a) & 販売可能ラック？(t);

販売可能ラック？ : 商品管理`ラック番号 ==> bool
販売可能ラック？(a) == 
  return (商品管理`ラック商品種別(a) <> nil and 商品管理`ラック商品数(a) > 0 and
          商品管理`ラック商品価格(a) < 残高 and 販売後返金可能？(a) );

-- 貨幣投入口が利用する操作
残高増 : 貨幣基本`金額 ==> ()
残高増(a) == 残高:= 残高 + a;

--残高減 : 貨幣基本`金額 ==> ()
--残高減(a) == 残高:= 残高 - a
--pre 残高 >= a;

--残高表示 : () ==> 貨幣基本`金額
--残高表示() == return 残高;

販売後返金可能？ : 商品管理`ラック番号 ==> bool
販売後返金可能？(a) == 
  let s = 返金計算(残高 - 商品管理`ラック商品価格(a)) in
  if s = nil then return false else return true;

-- 返金できない場合は nil を返す
返金計算 : 貨幣基本`金額 ==> [返金]
返金計算(a) == --返金用に紙幣・硬貨保持と硬貨チューブの合計を利用する
let s1 = 貨幣投入口`紙幣保持数(), s2 = 貨幣投入口`硬貨保持数(), s3 = 貨幣管理`硬貨チューブ内容() in
  return 返金計算re(a, s1, { i |-> s2(i)+s3(i) | i in set dom s2 })
--pre a > 0
post RESULT = nil or RESULT.紙幣 <= 1;

返金計算re : 貨幣基本`金額 * 貨幣基本`枚数 * 貨幣基本`硬貨枚数 ==> [返金]
返金計算re(a,b,c) == 
if a >= 1000 and b = 1 then -- 千円札は投入されている場合だけは返金にする（紙幣金庫からは出さない）
  let t = 返金計算re(a-1000,0,c) in 
  if t <> nil then return mk_返金(1,t.硬貨) else return nil
elseif a >= 500 and c(<円500>) > 0 then
  let c1 = {<円500> |-> c(<円500>)-1, <円100> |-> c(<円100>), <円50> |-> c(<円50>), <円10> |-> c(<円10>)} in
    let t = 返金計算re(a-500,0,c1) in 
    if t <> nil then 
      let s = {<円500> |-> t.硬貨(<円500>)+1, <円100> |-> t.硬貨(<円100>), <円50> |-> t.硬貨(<円50>), <円10> |-> t.硬貨(<円10>)} in return mk_返金(0,s)
    else return nil
elseif a >= 100 and c(<円100>) > 0 then 
  let c1 = {<円500> |-> c(<円500>), <円100> |-> c(<円100>)-1, <円50> |-> c(<円50>), <円10> |-> c(<円10>)} in
    let t = 返金計算re(a-100,0,c1) in 
    if t <> nil then 
      let s = {<円500> |-> t.硬貨(<円500>), <円100> |-> t.硬貨(<円100>)+1, <円50> |-> t.硬貨(<円50>), <円10> |-> t.硬貨(<円10>)} in return mk_返金(0,s)
    else return nil
elseif a >= 50 and c(<円50>) > 0 then 
  let c1 = {<円500> |-> c(<円500>), <円100> |-> c(<円100>), <円50> |-> c(<円50>)-1, <円10> |-> c(<円10>)} in
    let t = 返金計算re(a-50,0,c1) in 
    if t <> nil then 
      let s = {<円500> |-> t.硬貨(<円500>), <円100> |-> t.硬貨(<円100>), <円50> |-> t.硬貨(<円50>)+1, <円10> |-> t.硬貨(<円10>)} in return mk_返金(0,s)
    else return nil
elseif a >= 10 and c(<円10>) > 0 then 
  let c1 = {<円500> |-> c(<円500>), <円100> |-> c(<円100>), <円50> |-> c(<円50>), <円10> |-> c(<円10>)-1} in
    let t = 返金計算re(a-10,0,c1) in 
    if t <> nil then 
      let s = {<円500> |-> t.硬貨(<円500>), <円100> |-> t.硬貨(<円100>), <円50> |-> t.硬貨(<円50>), <円10> |-> t.硬貨(<円10>)+1} in return mk_返金(0,s)
    else return nil
elseif a = 0 then return mk_返金(0,硬貨数0000)
else return nil;
/*  if b = 1 then 
    let t = 返金計算re2(a-1000,c) in
    if t = [] then return nil else return mk_返金(1,t.硬貨) 
  else return nil
pre a >= 1000;*/

--釣銭切れ表示 : () ==> bool
--釣銭切れ表示() == return 貨幣管理`釣銭切れ？();

-- 販売するには、
-- 1. 商品をラックから１つ落とす（ラック商品数更新）
-- 2. 残高に商品価格を引く（残高更新）
-- 3. 返金する
販売する : ボタン番号 ==> ()
販売する(a) == 
let t = [c | c in set 販売ボタン(a)] in 
  let r = 販売ラック選択(t) in 
  ( 商品管理`ラック商品送出(r); 残高 := 残高 - 商品管理`ラック商品価格(r) )
pre 販売可能ボタン？(a);

販売ラック選択 : seq of 商品管理`ラック番号 ==> 商品管理`ラック番号
販売ラック選択(a) == 
  if 販売可能ラック？(hd a) then return (hd a)
  else return 販売ラック選択(tl a)
pre len a > 0;

-- 返金するには
-- 1. 今の残高で返金を計算する
-- 2. 投入口、硬貨チューブの順で紙幣・硬貨を出す
-- 3. 投入口に貨幣が残ってる場合は紙幣金庫・硬貨チューブに格納する
-- 4. 残高を 0 にする
返金する : () ==> ()
返金する() == (
  let t = 返金計算(残高), k = 貨幣投入口`紙幣保持数() in (
    IO`println("refunding...");
    IO`println(t);
    if t.紙幣 = 1 and k > 0 then 貨幣投入口`紙幣を返す()
    elseif t.紙幣 = 0 and k > 0 then 貨幣投入口`紙幣を格納する()
    else skip;
    硬貨返金(<円500>,t.硬貨(<円500>));
    硬貨返金(<円100>,t.硬貨(<円100>));
    硬貨返金(<円50>,t.硬貨(<円50>));
    硬貨返金(<円10>,t.硬貨(<円10>));
  );
  貨幣投入口`貨幣を格納する();
  残高 := 0;
);

硬貨返金 : 貨幣基本`硬貨 * 貨幣基本`枚数 ==> ()
硬貨返金(a,b) == 
if b > 0 then (
  if 貨幣投入口`硬貨保持数()(a) > 0 then (貨幣投入口`硬貨を返す(a); 硬貨返金(a,b-1))
  elseif 貨幣管理`硬貨チューブ内容()(a) > 0 then (貨幣管理`硬貨を返す(a); 硬貨返金(a,b-1))
  else skip;
  )
else skip;


-- 販売ボタンとラック商品との関係を設定するための操作ではなく、バックドアを利用する
-- バックドア for 状態アクセス
get_state : () ==> s販売管理
get_state() == return s販売管理;

set_state : s販売管理 ==> ()
set_state(a) == (販売ボタン := a.販売ボタン; 残高 := a.残高);

販売ボタン設定 : ボタンとラック対応関係 ==> ()
販売ボタン設定(a) == 販売ボタン := a;

end 販売管理


module verifier
exports all
imports from 貨幣基本 all, from 貨幣投入口 all, from 貨幣管理 all, from 商品管理 all, from 販売管理 all
definitions

types
sta_promela ::
  s1 : 貨幣基本`枚数 -- s貨幣投入口.s貨幣保持
  s2 : seq of 貨幣基本`枚数 -- s貨幣投入口.s硬貨保持
  s3 : 貨幣基本`枚数 -- s貨幣管理.紙幣金庫
  s4 : seq of 貨幣基本`枚数 -- s貨幣管理.硬貨金庫
  s5 : seq of 貨幣基本`枚数 -- s貨幣管理.硬貨チューブ
  s6 : seq of 商品管理`商品数 -- s商品管理.sラック商品数
  s7 : 貨幣基本`金額 -- s販売管理`残高

operations
initialization : () ==> ()
initialization() == (
  貨幣管理`硬貨チューブ設定(貨幣管理`硬貨チューブhalf);
  貨幣管理`紙幣金庫設定(貨幣管理`紙幣金庫half);
  商品管理`ラック商品設定(商品管理`ラック商品1, 商品管理`ラック商品数1);
  販売管理`販売ボタン設定(販売管理`ボタン設定1);
);

insert_bill : () ==> ()
insert_bill() == 貨幣投入口`紙幣投入(<円1000>)
pre 貨幣投入口`pre_紙幣投入(<円1000>,貨幣投入口`get_state());

insert_coin1 : () ==> ()
insert_coin1() == 貨幣投入口`硬貨投入(<円500>)
pre 貨幣投入口`pre_硬貨投入(<円500>,貨幣投入口`get_state());

insert_coin2 : () ==> ()
insert_coin2() == 貨幣投入口`硬貨投入(<円100>)
pre 貨幣投入口`pre_硬貨投入(<円100>,貨幣投入口`get_state());

insert_coin3 : () ==> ()
insert_coin3() == 貨幣投入口`硬貨投入(<円50>)
pre 貨幣投入口`pre_硬貨投入(<円50>,貨幣投入口`get_state());

insert_coin4 : () ==> ()
insert_coin4() == 貨幣投入口`硬貨投入(<円10>)
pre 貨幣投入口`pre_硬貨投入(<円10>,貨幣投入口`get_state());

push_btn : 販売管理`ボタン番号 ==> ()
push_btn(a) == 販売管理`販売する(a)
pre 販売管理`販売可能ボタン？(a);

refund : () ==> ()
refund() == 販売管理`返金する();


get_state : () ==> sta_promela
get_state() ==
let t1 = 貨幣投入口`get_state(), t2 = 貨幣管理`get_state(), t3 = 商品管理`get_state(), t4 = 販売管理`get_state() in
return
  mk_sta_promela(
    t1.s紙幣保持,
    [t1.s硬貨保持(<円500>),t1.s硬貨保持(<円100>),t1.s硬貨保持(<円50>),t1.s硬貨保持(<円10>)],
    t2.紙幣金庫,
    [t2.硬貨金庫(<円500>),t2.硬貨金庫(<円100>),t2.硬貨金庫(<円50>),t2.硬貨金庫(<円10>)],
    [t2.硬貨チューブ(<円500>),t2.硬貨チューブ(<円100>),t2.硬貨チューブ(<円50>),t2.硬貨チューブ(<円10>)],
    t3.sラック商品数,
    t4.残高
  );
    
set_state : sta_promela ==> ()
set_state(a) == 
  let t3 = 商品管理`get_state(), t4 = 販売管理`get_state() in (
    貨幣投入口`set_state( mk_貨幣投入口`s貨幣投入口( a.s1, { <円500> |-> a.s2(1), <円100> |-> a.s2(2), <円50> |-> a.s2(3), <円10> |-> a.s2(4) } ) );
    貨幣管理`set_state( mk_貨幣管理`s貨幣管理( a.s3, { <円500> |-> a.s4(1), <円100> |-> a.s4(2), <円50> |-> a.s4(3), <円10> |-> a.s4(4) }, 
                                                  { <円500> |-> a.s5(1), <円100> |-> a.s5(2), <円50> |-> a.s5(3), <円10> |-> a.s5(4) }  ) );
    商品管理`set_state( mk_商品管理`s商品管理( t3.sラック商品, a.s6 ) );
    販売管理`set_state( mk_販売管理`s販売管理( t4.販売ボタン, a.s7 ) );
  );

end verifier
